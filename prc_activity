#!/usr/bin/env perl

use strict;
use warnings;

use Net::GitHub;
use Mojo::UserAgent;
use Data::Dumper qw(Dumper);
use DateTime::Format::HTTP;
use JSON;
use Carp::Always;

# NOTE: this should run as a cron.  It's probably safe to run every 5 minutes but be careful of the rate limiting

my $CPAN_PRC = "http://cpan-prc.org/";
my $TEMP_PATH = "/tmp/cpan-prc/";

__PACKAGE__->new->run;

sub new {
    my $class = shift;
    bless {}, $class;
}

sub run {
    my $self = shift;

    my $token = $self->get_token;
    my $months = $self->get_months;

#    print Data::Dumper::Dumper($months);

    my $stats = { by_month => [ map { $_->{'stats'} } @$months ] };
    my $per_repo;
    my $pr = $self->github->pull_request;
    my $recent = [];
    my $i = 0;
    foreach my $month (0..$#$months) {
        foreach my $assign (@{ $months->[$month]->{'assignments'} }) {
            my $assigned = lc $assign->{'assignee'}->{'github_username'};
            my $pause_id = $assign->{'released_by'}->{'RJBS'};
            my $module   = $assign->{'distname'};
            my ($author, $repo) = split '/', $assign->{'repo'}->{'relpath'};

#        print Dumper [$assigned, $pause_id, $module, $author, $repo, $assign];

            my $pulls;
            # since done seems to be broken (hopefully temporarily), lets assume anyone with pull requests is done, except the current month
            if (! $assign->{'done'} && (! @{ $assign->{'pull_requests'} } || $month == $#$months)) {
                $pulls = eval { $pr->pulls($author, $repo, { state => 'all' }) };
                my $err = $@;
                my $remain = eval { $pr->ua->response->header('x-ratelimit-remaining') } || 0;
                my $reset = eval { $pr->ua->response->header('x-ratelimit-reset') } || 0;
                printf "%d requests made, %d remaining, resets in %d\n", ++$i, $remain, $reset - time;
                if ($err) {
                    warn "Failed to find pull requests for $author/$repo: $err\n";
                    next;
                }
            } else {
                # just trust what neil already fetched, although it has less info
                $pulls = $assign->{'pull_requests'};
            }
#        print Dumper $pulls;

            foreach my $pull (@$pulls) {
                my $s = $per_repo->{"$author/$repo"} ||= {};

                my ($closed, $merged, $created, $user) = @{ $pull }{ qw(closed_at merged_at created_at user) };
                $user = lc $user->{'login'} if $user && $user->{'login'};

                if ($pull->{'relpath'}) { # pull request fetched from neil
                    $closed = $pull->{'state'} eq 'closed';
                    $merged = $pull->{'state'} eq 'merged';
                    $user = lc $assign->{'assignee'}->{'github_username'};
                }

                # skip pull requests by anyone else (since the api call doesn't filter)
#            print Dumper [$user, $assigned, $closed, $merged, $created, $pull];
                next if $user ne $assigned;

                my $ref = $stats->{'by_month'}->[$month];
                $ref->{'pull_requests'}++;
                $ref->{'closed'}++ if $closed && ! $merged;
                $ref->{'merged'}++ if $merged;
                $ref->{'open'}++ if ! $closed && ! $merged;

                # TODO: remove these older style stats
                foreach ($s) { # per repo stats
                    $_->{'total'}++;
                    $_->{'open'}++ if ! $closed && ! $merged;
                    $_->{'merged'}++ if $merged;
                    $_->{'by_assigned'}++ if $user && $user eq $assigned;
                    $_->{'by_assigned_merged'}++ if $user && $user eq $assigned && $merged;
                    $_->{'months'}->{$month}++ if $month;
                    $_->{'by_assigned_months'}->{$month}++ if $month && $user && $user eq $assigned;
                    $_->{'assignee'}->{$assigned}++ if $user && $user eq $assigned;
                }

                push @$recent, $pull if $user && $user eq $assigned;
            }

        }
        print Dumper $stats;
    }
    @$recent = reverse sort { $a->{'created_at'} cmp $b->{'created_at'} } grep { $_->{'created_at'} } @$recent;

    @$recent = @{ $recent }[0..99] if @$recent > 99;

    # pull comment counts for recent pull requests
    foreach my $pull (@$recent) {
        my ($user, $repo) = ($pull->{'base'}->{'repo'}->{'owner'}->{'login'}, $pull->{'base'}->{'repo'}->{'name'});
        $pr->set_default_user_repo($user, $repo);
        my $comments = $pr->comments($pull->{'number'});
        $pull->{'num_comments'} = scalar @$comments;
    }

    print Dumper $stats, $per_repo;

    open my $fh, '+>', 'total_stats' or die;
    print $fh to_json($stats, { pretty => 1, utf8 => 1, canonical => 1 });
    close $fh;

    open $fh, '+>', 'per_repo' or die;
    print $fh to_json($per_repo, { pretty => 1, utf8 => 1, canonical => 1 });
    close $fh;

    open $fh, '+>', 'recent' or die;
    print $fh to_json($recent, { pretty => 1, utf8 => 1, canonical => 1 });
    close $fh;
}

# parse personal token from 'my_token' file
# TODO: read username/password and use oauth as fallback
sub get_token {
    my $self = shift;

    return $self->{'token'} ||= do {
        my $err = "Unable to find your token on first line of 'my_token' file (perhaps you didn't create it yet?)\n";
        open my $token_fh, '<', 'my_token' or die $err; # conveniently .gitignored (for security!)
        my $token = <$token_fh> // die $err;
        close $token_fh;

        return $token;
    }
}

sub get_months {
    my $self = shift;

    my $list = [];
    MONTH: foreach (qw(january february march april may june july august september october november december)) {
        my $file = "$_.json";
        my $path = "$TEMP_PATH$file";
        my $url = "$CPAN_PRC$file";

        # check cached file and refetch from url if older than cache
        my $refetch = 1;
        if (-e $path && -s $path) {
            my $modified = (stat(_))[9];

            my $head = $self->ua->head($url);
            my $expires = $head->res->headers->expires;
            next MONTH if ! $expires;
            my $epoch = DateTime::Format::HTTP->parse_datetime($expires)->epoch;
            $refetch = 0 if $modified < $epoch;
        }

        my $json;
        if ($refetch) {
            $json = eval { $self->ua->get($url)->res->json } or next MONTH;
            mkdir $TEMP_PATH if ! -d $TEMP_PATH;
            open my $fh, '+>', $path or warn $! and next MONTH;
            eval { print $fh to_json($json, { allow_blessed => 1 }) } or warn $@;
        } else {
            open my $fh, '<', $path or warn $! and next MONTH;
            my $raw = do { $/ = undef; <$fh> };
            $json = from_json($raw);
        }

        push @$list, $json;
    }
    return $list;
}

sub ua { my $self = shift; $self->{'ua'} ||= Mojo::UserAgent->new }
sub github { my $self = shift; $self->{'github'} ||= Net::GitHub->new(access_token => $self->get_token) }

# read list of users
sub special {
    my $self = shift;

    return {} if ! -e 'special';
    return $self->{'special'} ||= do {
        open my $fh, '<', 'special' or warn $! and return {};
        my $lines = do { $/ = undef; <$fh> };
        my $special = { map { $_ => 1 } grep { $_ } split /\n/, lc $lines };
        $special;
    }
}
